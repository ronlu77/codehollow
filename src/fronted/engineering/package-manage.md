---
date: 2023-10-23
category:
  - 前端
  - 工程化
tag: 
  - pnpm
  - npm
  - yarn
---

# 浅析`npm`，`yarn`，`pnpm`的区别

作为一名前端开发人员在项目中使用管理工具进行依赖管理是必不可缺的，但在日常使用过程中，并没有去深究目前几个主流包管理工具的异同，因此今天想要浅析一下`npm`,`yarn`,`pnpm`三者之间到底有什么区别，相较于`npm`，`yarn`，为何说`pnpm`是降维打击，它又有哪些优势呢？

## `npm2.x`

在npm2.x的时候，通过`npm install`命令安装依赖会在`/node_modules`中形成依赖树，be like：

![image-20231023105750611](https://raw.githubusercontent.com/ronlu77/pichost/main/image-20231023105750611.png)

这种嵌套结构视觉上看，文件之间的依赖关系很清晰，但是却给我们包管理带来了弊端，主要有一下几点：

1. 当依赖嵌套过深时，会超出windows最大文件路径；
2. 当不同依赖下依赖同个依赖资源会重复下载，磁盘空间浪费，造成冗余；
3. 如果依赖包下的依赖项中安装依赖存在依赖依赖项本身，会形成**依赖嵌套地狱**。

## `yarn` and `npm3.x`

由于`npm2.x`嵌套管理依赖包会引起上述缺陷问题，所以2016年新的包管理工具`yarn`应运而生。那么它和`npm2.x`又有哪些区别呢？

既然`npm2.x`嵌套管理依赖包存在缺陷，`yarn`管理包的结构不会再采用嵌套的方式而是**扁平化处理依赖**，be like：

![image-20231023111954723](https://raw.githubusercontent.com/ronlu77/pichost/main/image-20231023111954723.png)

此时，大部分的依赖不存在`node_modules`，但是仍然会有部分的依赖包存在`node_modules`。因为`yarn`只会将同一包的某一个版本提升，而其他版本则依旧会被嵌套使用。（在后来的`npm3.x`也是才用相同的处理方式）

相较于`npm2.x`磁盘利用率有所提升，同时也避免了windows路径超出问题，但是`yarn`并不完美。扁平化处理依赖和依赖包自身依赖的提升，造成了另一种问题的触发，在项目中可以使用未安装的依赖，这种现象被称为**“幽灵依赖”**。

幽灵依赖会带来什么问题呢？

如果当依赖包在后期更新不再使用当前的幽灵依赖了，那么项目中引入幽灵依赖的地方就会出错，导致项目无法运行。

相较于`npm2.x`，`yarn`以及`npm3.x`虽然有所提升，但是还是存在“幽灵变量”以及同一依赖包的其余版本重复复制造成的磁盘空间浪费问题。

## `pnpm`

与`yarn`和`npm3.x`相比，`pnpm`解决幽灵依赖和多版本重复复制的缺陷，那么它是通过什么原理来实现的呢？

原来`pnpm`采取操作系统机制Link（软硬链接的方式）来创建图数据结构进行包管理。硬链接（Hard Link）相当于一个文件的多个引用，它们公用一个`inode`标识（是文件的物理存储地址），软连接（Soft Link）相当于文件的复制，它通过文件的访问路径来查找源文件。通过`pnpm install`安装依赖后，be like:

![image-20231023144302911](https://raw.githubusercontent.com/ronlu77/pichost/main/image-20231023144302911.png)

同样是扁平化处理，`pnpm`通过在`/node_modules/.pnpm`下硬链接全局的`store`依赖包，在相互依赖的地方通过软连接进行连接，这样就可以避免依赖包只会提升一个版本，其余版本仍会多次复制的情况，大大减小了磁盘空间开销。

有别于`npm3.x`和`yarn`，`pnpm`不会将所有的依赖包都提升到`node_modules`文件夹下，而是只提升**直接依赖**（`package.json`中的`dependecies`）避免出现幽灵依赖的情况。就目前讨论的三个包管理工具来说`pnpm`还是 yyds！

:question: 关于硬软连接，后续需要再深入一下。
